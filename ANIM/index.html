<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Nintendo Style 3D Text Popup</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      background: radial-gradient(circle at top, #1c2b63 0, #050717 40%, #02020a 100%);
      color: #fdfdfd;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100vw;
    }

    /* 위/아래 2분할 레이아웃 */
    .top {
      flex: 3;
      position: relative;
      display: flex;
      align-items: stretch;
      justify-content: center;
      padding: 8px 8px 4px;
    }

    .bottom {
      flex: 2;
      padding: 10px 16px 16px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background:
        radial-gradient(circle at top, rgba(255, 255, 255, 0.1), transparent 50%),
        linear-gradient(180deg, rgba(5, 7, 22, 0.95), rgba(3, 5, 18, 0.96));
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 -12px 30px rgba(0, 0, 0, 0.75);
    }

    /* 상단 캔버스 박스 */
    .stage {
      position: relative;
      flex: 1;
      border-radius: 18px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background:
        radial-gradient(circle at top, rgba(255, 255, 255, 0.15), transparent 55%),
        radial-gradient(circle at bottom, rgba(255, 186, 120, 0.15), transparent 60%),
        linear-gradient(145deg, #050615, #060b23);
      box-shadow:
        0 18px 45px rgba(0, 0, 0, 0.9),
        0 0 40px rgba(0, 0, 0, 0.8);
    }

    #threeCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .hud {
      position: absolute;
      left: 14px;
      top: 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 2;
      pointer-events: none;
    }

    .hud-title {
      font-size: 0.78rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(237, 245, 255, 0.88);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
    }

    .hud-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.7rem;
      padding: 3px 10px;
      border-radius: 999px;
      background: radial-gradient(circle at 0 0, rgba(255, 255, 255, 0.6), transparent 60%),
                  linear-gradient(145deg, #ffcf3a, #ff6b2e);
      color: #3a1500;
      box-shadow:
        0 0 16px rgba(255, 179, 71, 0.7),
        0 5px 15px rgba(0, 0, 0, 0.8);
    }

    .hud-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: radial-gradient(circle, #ffffff 0, #ff1f4a 40%, #9d0505 80%);
      box-shadow: 0 0 10px rgba(255, 50, 80, 0.9);
    }

    .bottom-title {
      font-size: 0.9rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: rgba(240, 244, 255, 0.9);
    }

    .bottom-sub {
      font-size: 0.8rem;
      color: rgba(198, 207, 255, 0.9);
      line-height: 1.5;
    }

    .hint-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 6px;
      font-size: 0.8rem;
      color: rgba(180, 192, 255, 0.9);
    }

    .pill {
      border-radius: 999px;
      padding: 4px 9px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(8, 10, 32, 0.85);
    }

    .hint-key {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(6, 7, 22, 0.9);
      font-size: 0.75rem;
    }

    .footer {
      margin-top: auto;
      font-size: 0.72rem;
      color: rgba(154, 164, 220, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: center;
      opacity: 0.9;
    }

    .logo-mini {
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: rgba(255, 232, 146, 0.95);
    }

    @media (max-width: 768px) {
      .top {
        flex: 3;
      }
      .bottom {
        flex: 2;
      }
    }

    @media (max-width: 520px) {
      .bottom {
        padding: 10px 12px 14px;
      }
      .bottom-title {
        font-size: 0.82rem;
      }
      .bottom-sub {
        font-size: 0.78rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- 위쪽: 애니메이션 영역 -->
    <div class="top">
      <div class="stage">
        <div class="hud">
          <div class="hud-title">Nintendo-Style 3D Popup</div>
          <div class="hud-chip">
            <span class="hud-dot"></span>
            GAME TEXT DEMO
          </div>
        </div>
        <canvas id="threeCanvas"></canvas>
      </div>
    </div>

    <!-- 아래쪽: 설명 / UI 영역 -->
    <div class="bottom">
      <div class="bottom-title">닌텐도 게임 스타일 3D 텍스트</div>
      <div class="bottom-sub">
        위쪽 영역에서 텍스트가 <b>“툭!” 튀어나왔다가</b> 잠깐 떠 있고,
        다시 <b>팍</b> 사라지는 모션을 반복합니다.
        <br />
        두꺼운 엠보싱, 발광(emissive) 재질, 컬러 조명으로
        콘솔 게임 타이틀 같은 느낌을 만들었습니다.
      </div>

      <div class="hint-row">
        <div class="pill">
          여러 문구가 <b>순서대로</b> 나타났다 사라집니다:
          <br />
          「SUPER START!」 · 「PRESS BUTTON」 · 「READY GO!」
        </div>
        <div class="pill">
          속도·이징·스케일·알파 애니메이션 로직만 바꿔서
          쉽게 자신만의 연출로 확장할 수 있습니다.
        </div>
      </div>

      <div class="footer">
        <span>코드를 수정해서 텍스트/색상/카메라를 자유롭게 바꿔 보세요.</span>
        <span class="logo-mini">3D·TEXT</span>
      </div>
    </div>
  </div>

  <!-- Three.js & helpers -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/geometries/TextGeometry.js"></script>

  <script>
    // ============================
    // 기본 유틸
    // ============================
    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    // 부드러운 탄성 이징 (닌텐도 튀어나오는 맛)
    function easeOutBack(x) {
      const c1 = 1.70158;
      const c3 = c1 + 1;
      return 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2);
    }

    // ============================
    // Three.js 설정
    // ============================
    const canvas = document.getElementById("threeCanvas");
    let renderer, scene, camera;
    let font;
    let textMesh, textGroup;
    const clock = new THREE.Clock();

    // 애니메이션 사이클 설정
    const phrases = [
      "SUPER START!",
      "PRESS BUTTON",
      "READY GO!"
    ];

    const timings = {
      appear: 0.9,    // 등장
      hold: 1.4,      // 유지
      disappear: 0.9, // 퇴장
      gap: 0.3        // 아무것도 없음
    };
    const totalDuration = timings.appear + timings.hold + timings.disappear + timings.gap;

    let lastCycleIndex = -1;
    let currentPhraseIndex = 0;

    function initThree() {
      // 렌더러
      renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      resizeRenderer();

      // 씬
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050517, 0.18);

      // 카메라
      camera = new THREE.PerspectiveCamera(
        40,
        canvas.clientWidth / canvas.clientHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.2, 7);
      scene.add(camera);

      // 라이트 세팅 (게임 콘솔 느낌 컬러)
      const hemi = new THREE.HemisphereLight(0xfff6d4, 0x05040a, 1.0);
      scene.add(hemi);

      const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
      keyLight.position.set(5, 8, 6);
      keyLight.castShadow = false;
      scene.add(keyLight);

      const fillPink = new THREE.PointLight(0xff4c94, 1.2, 18);
      fillPink.position.set(-4, 2, 3);
      scene.add(fillPink);

      const fillBlue = new THREE.PointLight(0x48e0ff, 1.2, 22);
      fillBlue.position.set(3, -1, -4);
      scene.add(fillBlue);

      // 배경 파티클 (별 느낌)
      const starGeo = new THREE.BufferGeometry();
      const starCount = 450;
      const positions = new Float32Array(starCount * 3);
      for (let i = 0; i < starCount; i++) {
        positions[i * 3 + 0] = (Math.random() - 0.5) * 16;
        positions[i * 3 + 1] = Math.random() * 7 + 1;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
      }
      starGeo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      const starMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.06,
        transparent: true,
        opacity: 0.6,
        depthWrite: false
      });
      const stars = new THREE.Points(starGeo, starMat);
      stars.name = "stars";
      scene.add(stars);

      // 바닥 같은 살짝 반사되는 판
      const floorGeo = new THREE.CylinderGeometry(6, 7, 0.5, 32);
      const floorMat = new THREE.MeshStandardMaterial({
        color: 0x151534,
        metalness: 0.9,
        roughness: 0.4,
        transparent: true,
        opacity: 0.9,
        emissive: new THREE.Color(0x20205a)
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.position.set(0, -1.8, 0);
      scene.add(floor);

      // 텍스트 그룹
      textGroup = new THREE.Group();
      scene.add(textGroup);

      // 폰트 로드
      const loader = new THREE.FontLoader();
      loader.load(
        "https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json",
        (loadedFont) => {
          font = loadedFont;
          rebuildTextMesh(phrases[currentPhraseIndex]);
        },
        undefined,
        (err) => {
          console.error("폰트 로드 실패:", err);
        }
      );

      window.addEventListener("resize", resizeRenderer);
      animate();
    }

    function resizeRenderer() {
      if (!renderer) return;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      renderer.setSize(width, height, false);
      if (camera) {
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    }

    function rebuildTextMesh(text) {
      if (!font) return;

      if (textMesh) {
        textGroup.remove(textMesh);
        textMesh.geometry.dispose();
        textMesh.material.dispose();
        textMesh = null;
      }

      const depth = 0.5;
      const geo = new THREE.TextGeometry(text, {
        font,
        size: 1.1,
        height: depth,
        curveSegments: 14,
        bevelEnabled: true,
        bevelThickness: 0.22,
        bevelSize: 0.18,
        bevelOffset: 0,
        bevelSegments: 5
      });

      geo.computeBoundingBox();
      geo.center();

      const baseColor = new THREE.Color(0xfff79b); // 노란 계열
      const mat = new THREE.MeshStandardMaterial({
        color: baseColor,
        metalness: 0.75,
        roughness: 0.25,
        emissive: new THREE.Color(0xffb53f),
        emissiveIntensity: 0.7,
        transparent: true,
        opacity: 0.0 // 처음에는 보이지 않게
      });

      textMesh = new THREE.Mesh(geo, mat);
      textMesh.position.y = -2.0;
      textMesh.scale.set(0, 0, 0);
      textGroup.add(textMesh);
    }

    // ============================
    // 애니메이션 루프
    // ============================
    function animate() {
      requestAnimationFrame(animate);
      if (!renderer || !scene || !camera) return;

      const elapsed = clock.getElapsedTime();
      const cycleIndex = Math.floor(elapsed / totalDuration);
      const tInCycle = elapsed % totalDuration;

      // 새로운 사이클에 들어가면 문구 변경
      if (cycleIndex !== lastCycleIndex && font) {
        lastCycleIndex = cycleIndex;
        currentPhraseIndex = (currentPhraseIndex + 1) % phrases.length;
        rebuildTextMesh(phrases[currentPhraseIndex]);
      }

      // 텍스트 애니메이션
      if (textMesh) {
        const m = textMesh;
        let scale = 0;
        let opacity = 0;
        let posY = -2.0;
        const baseScale = 1.15;

        if (tInCycle < timings.appear) {
          // 등장 구간
          const p = clamp(tInCycle / timings.appear, 0, 1);
          const e = easeOutBack(p);
          scale = baseScale * e;
          opacity = p;
          posY = lerp(-2.0, 0.3, p);
        } else if (tInCycle < timings.appear + timings.hold) {
          // 유지 구간
          const localT = tInCycle - timings.appear;
          const p = clamp(localT / timings.hold, 0, 1);
          const breathe = 0.04 * Math.sin(elapsed * 6.0);
          scale = baseScale * (1 + breathe);
          opacity = 1.0;
          posY = 0.3 + Math.sin(elapsed * 4.0) * 0.05;
        } else if (tInCycle < timings.appear + timings.hold + timings.disappear) {
          // 사라지는 구간
          const localT = tInCycle - timings.appear - timings.hold;
          const p = clamp(localT / timings.disappear, 0, 1);
          scale = baseScale * (1 + 0.7 * p);
          opacity = 1.0 - p;
          posY = 0.3 + p * 1.0;
        } else {
          // gap 구간 (안 보이게)
          scale = 0;
          opacity = 0;
          posY = -2.0;
        }

        m.scale.set(scale, scale, scale);
        m.position.y = posY;
        m.material.opacity = opacity;

        // 살짝 회전감 (게임 연출 느낌)
        m.rotation.y = Math.sin(elapsed * 1.4) * 0.22;
        m.rotation.x = Math.cos(elapsed * 0.9) * 0.1;
      }

      // 배경 별 움직임
      const stars = scene.getObjectByName("stars");
      if (stars) {
        stars.rotation.y += 0.01;
        stars.position.y = 0.5 + Math.sin(elapsed * 0.35) * 0.6;
      }

      // 카메라 약간 흔들림
      camera.position.x = Math.sin(elapsed * 0.4) * 0.4;
      camera.position.y = 1.2 + Math.cos(elapsed * 0.7) * 0.15;
      camera.lookAt(0, 0, 0);

      renderer.render(scene, camera);
    }

    // 초기화
    window.addEventListener("load", () => {
      initThree();
    });
  </script>
</body>
</html>